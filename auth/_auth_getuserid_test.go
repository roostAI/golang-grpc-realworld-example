// ********RoostGPT********
/*
Test generated by RoostGPT for test unit-golang using AI Type Azure Open AI and AI Model india-gpt-4o

ROOST_METHOD_HASH=GetUserID_f2dd680cb2
ROOST_METHOD_SIG_HASH=GetUserID_e739312e3d

FUNCTION_DEF=func GetUserID(ctx context.Context) (uint, error) 
Here are the Go test scenarios for the `GetUserID` function, capturing many typical cases, including normal operations and various edge cases:

#### Test Scenario 1: Successfully Retrieve User ID from Valid Token

```
Scenario 1: Successfully Retrieve User ID from Valid Token

Details:
  Description: This test checks if the function correctly extracts the user ID from a valid JWT token.
  Execution:
    Arrange: Mock a valid JWT token string using a valid `claims` object with a future expiration date. Set this in the gRPC metadata context.
    Act: Call `GetUserID` with the context containing the token.
    Assert: Validate that the returned user ID matches the expected user ID and the error is nil.
  Validation:
    Explain: The assertion verifies that the function correctly decodes a well-formed, valid token.
    Discuss: This is crucial as successful user authentication depends on correctly parsing the token.
```

#### Test Scenario 2: Invalid Token String in Metadata

```
Scenario 2: Invalid Token String in Metadata

Details:
  Description: This test assesses handling when the token string cannot be retrieved from the gRPC metadata.
  Execution:
    Arrange: Setup a context without the required authentication metadata or with malformed metadata.
    Act: Execute `GetUserID`.
    Assert: Confirm that the function returns a zero value and the expected error indicating the missing or unavailable token string.
  Validation:
    Explain: Ensures the function can gracefully handle missing token strings, essential for robust authentication handling.
    Discuss: This error handling ensures that attempts to invoke endpoints without proper tokens are caught promptly.
```

#### Test Scenario 3: Token Expired

```
Scenario 3: Token Expired

Details:
  Description: This test checks the functionâ€™s response when a valid token is expired.
  Execution:
    Arrange: Craft a JWT token with valid claims but an expired `ExpiresAt` timestamp. Supply this token in the metadata.
    Act: Invoke `GetUserID`.
    Assert: Verify the function returns zero for user ID and an error indicating token expiration.
  Validation:
    Explain: The assertion confirms that expiration is a critical validity check for JWTs, safeguarding security.
    Discuss: It maintains security by preventing users with expired tokens from gaining access, enforcing timely token renewal.
```

#### Test Scenario 4: Malformed Token

```
Scenario 4: Malformed Token

Details:
  Description: Assess functionality when a malformed JWT token is processed.
  Execution:
    Arrange: Provide a clearly malformed JWT token string in the context metadata.
    Act: Trigger `GetUserID`.
    Assert: Check for zero user ID and a specific error message about token malformation.
  Validation:
    Explain: Verification here ensures the function appropriately recognizes invalid formats, enhancing API robustness.
    Discuss: Important for resilience against improperly structured or tampered tokens often observed during attacks.
```

#### Test Scenario 5: Valid Token but Incorrect Claims Type

```
Scenario 5: Valid Token but Incorrect Claims Type

Details:
  Description: Test the behavior when the claims returned are not of the expected type.
  Execution:
    Arrange: Create a JWT token using a claims structure other than `claims`, insert it into metadata.
    Act: Call `GetUserID`.
    Assert: Validate returning zero and an error regarding token claims mapping.
  Validation:
    Explain: The assertion checks the function strictly verifies token claims structures, crucial for type safety.
    Discuss: Ensures integrity by validating expected claim formats without unexpected or false-positive reading of claims.
```

#### Test Scenario 6: Invalid JWT Signature

```
Scenario 6: Invalid JWT Signature

Details:
  Description: Evaluate behavior when the JWT token signature is invalid.
  Execution:
    Arrange: Generate a JWT token with an invalid signature and assign it in context metadata.
    Act: Call `GetUserID`.
    Assert: Confirm a zero user ID and an error related to token signature verification failure.
  Validation:
    Explain: Ensures the function accurately validates token authenticity, key for guarding against tampered tokens.
    Discuss: Critical for maintaining trust, as the token signature verifies the source authenticity of each token.
```

These scenarios thoroughly test the `GetUserID` function, addressing a mix of successful, failing, and edge conditions necessary to ensure robust application behavior and security.
*/

// ********RoostGPT********
package auth

import (
	"context"
	"errors"
	"fmt"
	"testing"
	"time"

	"github.com/dgrijalva/jwt-go"
	grpc_auth "github.com/grpc-ecosystem/go-grpc-middleware/auth"
	"github.com/stretchr/testify/assert"
	"google.golang.org/grpc/metadata"
)

var jwtSecret = []byte("mySecret")

type claims struct {
	UserID uint `json:"user_id"`
	jwt.StandardClaims
}

func TestGetUserId(t *testing.T) {
	type testData struct {
		name       string
		tokenSetup func() string
		expectID   uint
		expectErr  string
	}

	tests := []testData{
		{
			name: "Successfully Retrieve User ID from Valid Token",
			tokenSetup: func() string {
				expirationTime := time.Now().Add(5 * time.Minute).Unix()
				token := jwt.NewWithClaims(jwt.SigningMethodHS256, &claims{
					UserID: 42,
					StandardClaims: jwt.StandardClaims{
						ExpiresAt: expirationTime,
					},
				})
				tokenString, _ := token.SignedString(jwtSecret)
				return tokenString
			},
			expectID:  42,
			expectErr: "",
		},
		{
			name: "Invalid Token String in Metadata",
			tokenSetup: func() string {
				return ""
			},
			expectID:  0,
			expectErr: "Request unauthenticated with Token",
		},
		{
			name: "Token Expired",
			tokenSetup: func() string {
				expirationTime := time.Now().Add(-5 * time.Minute).Unix()
				token := jwt.NewWithClaims(jwt.SigningMethodHS256, &claims{
					UserID: 42,
					StandardClaims: jwt.StandardClaims{
						ExpiresAt: expirationTime,
					},
				})
				tokenString, _ := token.SignedString(jwtSecret)
				return tokenString
			},
			expectID:  0,
			expectErr: "token expired",
		},
		{
			name: "Malformed Token",
			tokenSetup: func() string {
				return "malformed.token.string"
			},
			expectID:  0,
			expectErr: "invalid token: it's not even a token",
		},
		{
			name: "Valid Token but Incorrect Claims Type",
			tokenSetup: func() string {
				expirationTime := time.Now().Add(5 * time.Minute).Unix()
				token := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{
					"user_id":   "not-an-integer", // incorrect type
					"exp":       expirationTime,
				})
				tokenString, _ := token.SignedString(jwtSecret)
				return tokenString
			},
			expectID:  0,
			expectErr: "invalid token: cannot map token to claims",
		},
		{
			name: "Invalid JWT Signature",
			tokenSetup: func() string {
				expirationTime := time.Now().Add(5 * time.Minute).Unix()
				token := jwt.NewWithClaims(jwt.SigningMethodHS256, &claims{
					UserID: 42,
					StandardClaims: jwt.StandardClaims{
						ExpiresAt: expirationTime,
					},
				})
				tokenString, _ := token.SignedString([]byte("wrongSecret"))
				return tokenString
			},
			expectID:  0,
			expectErr: "invalid token: couldn't handle this token; verification failed",
		},
	}

	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			tokenString := test.tokenSetup()
			ctx := createContextWithToken(tokenString)

			userID, err := GetUserID(ctx)

			if test.expectErr != "" {
				assert.EqualError(t, err, test.expectErr)
			} else {
				assert.NoError(t, err)
			}

			assert.Equal(t, test.expectID, userID)
		})
	}
}

// createContextWithToken is a utility function to insert token into context metadata
func createContextWithToken(token string) context.Context {
	md := metadata.Pairs("authorization", "Token "+token)
	return metadata.NewIncomingContext(context.Background(), md)
}

func GetUserID(ctx context.Context) (uint, error) {
	tokenString, err := grpc_auth.AuthFromMD(ctx, "Token")
	if err != nil {
		return 0, err
	}

	token, err := jwt.ParseWithClaims(tokenString, &claims{}, func(token *jwt.Token) (interface{}, error) {
		return jwtSecret, nil
	})
	if !token.Valid {
		if ve, ok := err.(*jwt.ValidationError); ok {
			if ve.Errors&jwt.ValidationErrorMalformed != 0 {
				return 0, errors.New("invalid token: it's not even a token")
			} else if ve.Errors&(jwt.ValidationErrorExpired|jwt.ValidationErrorNotValidYet) != 0 {
				return 0, errors.New("token expired")
			} else {
				return 0, fmt.Errorf("invalid token: couldn't handle this token; %w", err)
			}
		} else {
			return 0, fmt.Errorf("invalid token: couldn't handle this token; %w", err)
		}
	}

	c, ok := token.Claims.(*claims)
	if !ok {
		return 0, errors.New("invalid token: cannot map token to claims")
	}

	if c.ExpiresAt < time.Now().Unix() {
		return 0, errors.New("token expired")
	}

	return c.UserID, nil
}
