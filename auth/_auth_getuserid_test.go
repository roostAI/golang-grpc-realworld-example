// ********RoostGPT********
/*
Test generated by RoostGPT for test unit-golang using AI Type Azure Open AI and AI Model india-gpt-4o

ROOST_METHOD_HASH=GetUserID_f2dd680cb2
ROOST_METHOD_SIG_HASH=GetUserID_e739312e3d

FUNCTION_DEF=func GetUserID(ctx context.Context) (uint, error) 
Here are the test scenarios for the `GetUserID` function:

### Scenario 1: Successful Token Parsing and Valid UserID Retrieval

**Details:**  
- **Description:** This test checks the successful parsing of a valid JWT token to extract and return the `UserID`. This scenario represents the normal operation where everything functions correctly.
- **Execution:**
  - **Arrange:** 
    - Prepare a JWT token with a valid `UserID` and non-expired claims.
    - Set up the context with this token in the metadata.
  - **Act:** Invoke `GetUserID` with the prepared context.
  - **Assert:** Verify that the returned `UserID` matches the one encoded in the token and the error is `nil`.
- **Validation:**   
  - This assertion ensures the function correctly parses valid tokens and extracts the `UserID`. It's crucial for the service's authentication flow, confirming authorized access.

### Scenario 2: Missing Token in Context

**Details:**  
- **Description:** This test validates the function's response when there is no token present in the context metadata, ensuring it handles errors gracefully.
- **Execution:**
  - **Arrange:** 
    - Create a context without any authentication metadata.
  - **Act:** Invoke `GetUserID` with this context.
  - **Assert:** Check that the returned `UserID` is `0` and the error indicates a missing token.
- **Validation:**  
  - Ensures robustness by verifying the function can handle cases without tokens, which is essential for mitigating unauthorized access attempts.

### Scenario 3: Malformed Token

**Details:**  
- **Description:** This test checks how the function responds to a malformed token. It should recognize the token's invalid structure.
- **Execution:**
  - **Arrange:** 
    - Create a malformed JWT token string.
    - Set up the context carrying this token.
  - **Act:** Call `GetUserID` with the malformed token context.
  - **Assert:** Verify that `UserID` is `0` and the error reflects a "malformed token".
- **Validation:**  
  - Confirms the function can detect and report malformed tokens, critical for ensuring system integrity against compromised inputs.

### Scenario 4: Token Expired

**Details:**  
- **Description:** Validate that the function detects and responds correctly to an expired token.
- **Execution:**
  - **Arrange:** 
    - Generate a JWT token with an `ExpiresAt` timestamp in the past.
    - Add this token to the context metadata.
  - **Act:** Invoke the function with this expired token context.
  - **Assert:** Verify the function returns `0` for `UserID` and an error indicating "token expired".
- **Validation:**  
  - Important for enforcing access control by ensuring only current sessions gain access, preventing reuse of old tokens.

### Scenario 5: Invalid Token Signature

**Details:**  
- **Description:** Tests the function's handling of a token with an invalid signature, ensuring it can't be processed.
- **Execution:**
  - **Arrange:** 
    - Create a JWT token with an invalid signature using a different signing key.
    - Include this token in the context.
  - **Act:** Call `GetUserID` with this manipulated context.
  - **Assert:** Ensure `UserID` is `0` and error indicates issues in handling the token.
- **Validation:**  
  - Verifies that tokens with incorrect signatures are caught, maintaining the authentication security.

### Scenario 6: Token with Incorrect Claims Type

**Details:**  
- **Description:** Check if the function appropriately handles a token that doesn't map to the expected claims struct, which might be due to incorrect claims type or format.
- **Execution:**
  - **Arrange:** 
    - Create a JWT token with claims of an unexpected type or format.
    - Add it to the context.
  - **Act:** Invoke the function using this context.
  - **Assert:** Validate that the function returns `0` for `UserID` and an error about "cannot map token to claims".
- **Validation:**  
  - Prevents potential issues caused by processing claims data improperly, ensuring reliable claim interpretation.

### Scenario 7: Unsupported Signing Method

**Details:**  
- **Description:** Ensure the function rejects a token signed with an unsupported algorithm, which could arise from security protocol mismatches.
- **Execution:**
  - **Arrange:** 
    - Create a JWT token using an unsupported signing method.
    - Pass this token through the context.
  - **Act:** Execute `GetUserID` using the context with this token.
  - **Assert:** Confirm that the returned `UserID` is `0` and error denotes handling issues.
- **Validation:**  
  - Critical for security by ensuring that only tokens with sanctioned methods are processed, maintaining consistency in added security mechanisms.
*/

// ********RoostGPT********
package auth

import (
	"context"
	"errors"
	"fmt"
	"os"
	"strings"
	"testing"
	"time"

	"github.com/dgrijalva/jwt-go"
	grpc_auth "github.com/grpc-ecosystem/go-grpc-middleware/auth"
	"github.com/grpc-ecosystem/go-grpc-middleware/util/metautils"
	// "google.golang.org/grpc/codes"
	// "google.golang.org/grpc/status"
)

func TestGetUserId(t *testing.T) {
	validUserID := uint(123)
	expiredTime := time.Now().Add(-time.Hour).Unix()
	validTime := time.Now().Add(time.Hour).Unix()

	testCases := []struct {
		name         string
		token        string
		expectedID   uint
		expectedErr  string
		headerScheme string
	}{
		{
			name:         "Successful Token Parsing and Valid UserID Retrieval",
			token:        newToken(validUserID, validTime, jwt.SigningMethodHS256),
			expectedID:   validUserID,
			expectedErr:  "",
			headerScheme: "Token",
		},
		{
			name:         "Missing Token in Context",
			token:        "",
			expectedID:   0,
			expectedErr:  "Request unauthenticated with Token",
			headerScheme: "Token",
		},
		{
			name:         "Malformed Token",
			token:        "malformed.token.string",
			expectedID:   0,
			expectedErr:  "invalid token: it's not even a token",
			headerScheme: "Token",
		},
		{
			name:         "Token Expired",
			token:        newToken(validUserID, expiredTime, jwt.SigningMethodHS256),
			expectedID:   0,
			expectedErr:  "token expired",
			headerScheme: "Token",
		},
		{
			name:         "Invalid Token Signature",
			token:        newTokenWithDifferentKey(validUserID, validTime),
			expectedID:   0,
			expectedErr:  "invalid token: couldn't handle this token; key is of invalid type",
			headerScheme: "Token",
		},
		{
			name:         "Token with Incorrect Claims Type",
			token:        newTokenWithWrongClaims(),
			expectedID:   0,
			expectedErr:  "invalid token: cannot map token to claims",
			headerScheme: "Token",
		},
		{
			name:         "Unsupported Signing Method",
			token:        newToken(validUserID, validTime, jwt.SigningMethodRS256),
			expectedID:   0,
			expectedErr:  "signing method RS256 is invalid",
			headerScheme: "Token",
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			ctx := metautils.NiceMD(map[string][]string{"authorization": {tc.headerScheme + " " + tc.token}}).ToIncoming(context.Background())
			userID, err := GetUserID(ctx)

			if userID != tc.expectedID {
				t.Fatalf("expected userID %d, got %d", tc.expectedID, userID)
			}

			if (err == nil && tc.expectedErr != "") || (err != nil && err.Error() != tc.expectedErr) {
				t.Fatalf("expected error %q, got %q", tc.expectedErr, err)
			}

			t.Logf("Test case %q PASSED", tc.name)
		})
	}
}

// Helper functions to generate various tokens for testing scenarios
func newToken(userID uint, exp int64, method jwt.SigningMethod) string {
	token := jwt.NewWithClaims(method, &claims{
		UserID: userID,
		StandardClaims: jwt.StandardClaims{
			ExpiresAt: exp,
		},
	})
	tokenString, _ := token.SignedString(jwtSecret) // TODO: handle error in production code appropriately
	return tokenString
}

func newTokenWithDifferentKey(userID uint, exp int64) string {
	wrongSecret := []byte("another_secret")
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, &claims{
		UserID: userID,
		StandardClaims: jwt.StandardClaims{
			ExpiresAt: exp,
		},
	})
	tokenString, _ := token.SignedString(wrongSecret) // TODO: handle error in production code appropriately
	return tokenString
}

func newTokenWithWrongClaims() string {
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{
		"unexpected": "value",
	})
	tokenString, _ := token.SignedString(jwtSecret) // TODO: handle error in production code appropriately
	return tokenString
}

var jwtSecret = []byte(os.Getenv("JWT_SECRET"))
