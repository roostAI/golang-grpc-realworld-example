// ********RoostGPT********
/*
Test generated by RoostGPT for test unit-golang using AI Type Azure Open AI and AI Model india-gpt-4o

ROOST_METHOD_HASH=DeleteComment_452af2f984
ROOST_METHOD_SIG_HASH=DeleteComment_27615e7d69

FUNCTION_DEF=func (h *Handler) DeleteComment(ctx context.Context, req *pb.DeleteCommentRequest) (*pb.Empty, error) 
```
Scenario 1: Successful Comment Deletion

Details:
  Description: Verify that the comment is successfully deleted when all conditions are metâ€”authenticated user, valid comment ID, correct article slug, and ownership of the comment by the current user.
Execution:
  Arrange: 
    - Mock the `auth.GetUserID` function to return a valid user ID.
    - Prepare a `GetByID` method in `UserStore` that returns a matching user.
    - Arrange `ArticleStore` to provide the correct comment when queried with ID.
    - Ensure the comment has the correct article slug and the user ID matches the owner.
  Act:
    - Call `DeleteComment` with valid `DeleteCommentRequest`.
  Assert:
    - Check that `DeleteComment` returns no error and an `Empty` object.
Validation:
  The assertions validate the normal flow of comment deletion, confirming that the application behaves correctly for valid inputs and user permissions, which is crucial for proper comment management.

Scenario 2: Unauthenticated User

Details:
  Description: Ensure the service returns an error if the user is not authenticated.
Execution:
  Arrange:
    - Make `auth.GetUserID` return an error indicating the user is not authenticated.
  Act:
    - Use a `DeleteCommentRequest` with a valid comment.
  Assert:
    - Confirm that the function returns an `Unauthenticated` gRPC error.
Validation:
  This test checks the authentication mechanism integration, ensuring that unauthenticated users cannot delete comments.

Scenario 3: Nonexistent User

Details:
  Description: Test how the service reacts when the current user cannot be found in the user store.
Execution:
  Arrange:
    - Mock a valid user ID from `auth.GetUserID`.
    - Make `UserStore.GetByID` return an error indicating the user doesn't exist.
  Act:
    - Invoke `DeleteComment` with valid parameters.
  Assert:
    - Expect a `NotFound` gRPC error for the user.
Validation:
  Verifies user existence checks, ensuring the system responds correctly when user records are missing, crucial for data integrity and security.

Scenario 4: Invalid Comment ID Format

Details:
  Description: Validate the behavior when the `id` field in the request cannot be converted to a valid integer.
Execution:
  Arrange:
    - Use `auth.GetUserID` to return a valid user ID.
    - Create a `DeleteCommentRequest` where `id` is an invalid string (e.g., "abc").
  Act:
    - Call `DeleteComment` with malformed ID.
  Assert:
    - The function should return an `InvalidArgument` gRPC error.
Validation:
  Tests input validation logic, ensuring that the application robustly handles malformed request data, a common edge case.

Scenario 5: Comment Not Found

Details:
  Description: Check the response when a valid but non-existent comment ID is provided.
Execution:
  Arrange:
    - Set up a valid comment ID that doesn't map to any existing comment.
  Act:
    - Call `DeleteComment` with this ID.
  Assert:
    - Verify an `InvalidArgument` gRPC error is returned.
Validation:
  Ensures the system correctly handles requests referencing nonexistent objects, fostering user trust and error resilience.

Scenario 6: Incorrect Slug for Comment

Details:
  Description: Ensure the method fails when the provided slug does not match the comment's article ID.
Execution:
  Arrange:
    - Mock a valid user ID and comment ID.
    - Set the method to return a comment with an expected article ID.
    - Provide a `DeleteCommentRequest` with a mismatching slug.
  Act:
    - Invoke `DeleteComment`.
  Assert:
    - Expect an `InvalidArgument` gRPC error due to slug mismatch.
Validation:
  Verifies business logic to link comments to specific articles, maintaining data consistency and integrity.

Scenario 7: Comment Ownership Violation

Details:
  Description: Verify error returned when the comment to be deleted does not belong to the requesting user.
Execution:
  Arrange:
    - Set up a valid comment with correct article ID but owned by a different user than the current user.
  Act:
    - Execute `DeleteComment` with a comment owned by another user.
  Assert:
    - Ensure the function returns an `InvalidArgument` gRPC error suggesting permission violation.
Validation:
  Tests the enforcement of authorization rules, ensuring comments are only deletable by their owners, critical for application security.

Scenario 8: Database Deletion Failure

Details:
  Description: Simulate and test handling of failures in the deletion operation in the database.
Execution:
  Arrange:
    - Mock all preconditions for a successful delete.
    - Then, simulate a failure when attempting to delete from `ArticleStore`.
  Act:
    - Invoke `DeleteComment`.
  Assert:
    - Confirm it returns an `InvalidArgument` gRPC error due to deletion failure.
Validation:
  Validates graceful error handling during database operation failures, ensuring system stability and proper error reporting.
```

*/

// ********RoostGPT********
package handler

import (
	"context"
	"errors"
	"fmt"
	"strconv"
	"testing"

	"github.com/DATA-DOG/go-sqlmock"
	"github.com/golang/mock/gomock"
	"github.com/raahii/golang-grpc-realworld-example/auth"
	"github.com/raahii/golang-grpc-realworld-example/model"
	pb "github.com/raahii/golang-grpc-realworld-example/proto"
	"github.com/raahii/golang-grpc-realworld-example/store"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
	"github.com/rs/zerolog"
)

func TestHandlerDeleteComment(t *testing.T) {
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()

	// Mock ArticleStore
	mockArticleStore := store.NewMockArticleStore(ctrl)
	// Mock UserStore
	mockUserStore := store.NewMockUserStore(ctrl)

	tests := []struct {
		name             string
		userID           uint
		authError        error
		getUserError     error
		commentID        string
		comment          *model.Comment
		commentError     error
		slug             string
		deleteCommentErr error
		wantErr          codes.Code
	}{
		{
			name:        "Successful Comment Deletion",
			userID:      1,
			authError:   nil,
			commentID:   "10",
			comment:     &model.Comment{ID: 10, ArticleID: 10, UserID: 1},
			slug:        "10",
			wantErr:     codes.OK,
		},
		{
			name:        "Unauthenticated User",
			authError:   errors.New("unauthenticated"),
			wantErr:     codes.Unauthenticated,
		},
		{
			name:        "Nonexistent User",
			userID:      1,
			authError:   nil,
			getUserError: status.Error(codes.NotFound, "user not found"),
			wantErr:     codes.NotFound,
		},
		{
			name:        "Invalid Comment ID Format",
			userID:      1,
			authError:   nil,
			commentID:   "abc",
			wantErr:     codes.InvalidArgument,
		},
		{
			name:        "Comment Not Found",
			userID:      1,
			authError:   nil,
			commentID:   "10",
			commentError: errors.New("comment not found"),
			wantErr:     codes.InvalidArgument,
		},
		{
			name:        "Incorrect Slug for Comment",
			userID:      1,
			authError:   nil,
			commentID:   "10",
			comment:     &model.Comment{ID: 10, ArticleID: 11, UserID: 1},
			slug:        "12",
			wantErr:     codes.InvalidArgument,
		},
		{
			name:        "Comment Ownership Violation",
			userID:      2,
			authError:   nil,
			commentID:   "10",
			comment:     &model.Comment{ID: 10, ArticleID: 10, UserID: 1},
			slug:        "10",
			wantErr:     codes.InvalidArgument,
		},
		{
			name:             "Database Deletion Failure",
			userID:           1,
			authError:        nil,
			commentID:        "10",
			comment:          &model.Comment{ID: 10, ArticleID: 10, UserID: 1},
			slug:             "10",
			deleteCommentErr: errors.New("delete failed"),
			wantErr:          codes.InvalidArgument,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			ctx := context.TODO()
			// Mock auth.GetUserID to simulate user authentication
			auth.MockGetUserID = func(ctx context.Context) (uint, error) {
				return tt.userID, tt.authError
			}

			// Mock UserStore.GetByID
			mockUserStore.EXPECT().GetByID(tt.userID).Return(&model.User{ID: tt.userID}, tt.getUserError).AnyTimes()

			// Mock ArticleStore.GetCommentByID
			commentID, _ := strconv.Atoi(tt.commentID)
			mockArticleStore.EXPECT().GetCommentByID(uint(commentID)).Return(tt.comment, tt.commentError).AnyTimes()

			// Mock ArticleStore.DeleteComment
			if tt.comment != nil {
				mockArticleStore.EXPECT().DeleteComment(gomock.Any()).Return(tt.deleteCommentErr).AnyTimes()
			}

			h := &Handler{
				logger:      zerolog.Nop(), // Use no-op logger here for simplicity
				us:          mockUserStore,
				as:          mockArticleStore,
			}

			req := &pb.DeleteCommentRequest{
				Slug: tt.slug,
				Id:   tt.commentID,
			}

			_, err := h.DeleteComment(ctx, req)
			if status.Code(err) != tt.wantErr {
				t.Errorf("DeleteComment() error = %v, wantErr %v", err, tt.wantErr)
			}
		})
	}
}
