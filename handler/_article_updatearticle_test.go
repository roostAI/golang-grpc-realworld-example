// ********RoostGPT********
/*
Test generated by RoostGPT for test unit-golang using AI Type Azure Open AI and AI Model india-gpt-4o

ROOST_METHOD_HASH=UpdateArticle_c5b82e271b
ROOST_METHOD_SIG_HASH=UpdateArticle_f36cc09d87

FUNCTION_DEF=func (h *Handler) UpdateArticle(ctx context.Context, req *pb.UpdateArticleRequest) (*pb.ArticleResponse, error) 
Here's a comprehensive breakdown of test scenarios for the `UpdateArticle` function. These scenarios aim to cover various paths, including normal and exceptional flows.

### Scenario 1: Successful Article Update

Details:
- Description: Tests the successful update of an article when the user is authenticated and authorized to update the article. This covers the main path where all validations pass, and the article is updated in the store.

Execution:
- Arrange: Authenticate a user who is also the author of the article. Set up mock stores to return the necessary user and article data. No errors should be returned from any dependencies.
- Act: Call `UpdateArticle` with a valid `UpdateArticleRequest` containing changes for the article.
- Assert: Verify the returned `ArticleResponse` contains the updated article data and no error is returned.

Validation:
- The assertion checks if the updated article data reflects the changes. This test confirms that all components of the function work together to update the article correctly, aligning with user expectations of modifying content.

### Scenario 2: Unauthenticated User Attempt

Details:
- Description: Validates handling of an unauthenticated user trying to update an article, ensuring proper error messaging and response codes.

Execution:
- Arrange: Context is set up without a valid user authentication token.
- Act: Invoke `UpdateArticle` with the request.
- Assert: Confirm that the error returned is `Unauthenticated` with the appropriate status code.

Validation:
- This assertion verifies the security mechanism of the application, preventing unauthorized access to content modification.

### Scenario 3: User Tries to Update Another User's Article

Details:
- Description: Ensures that an authenticated but unauthorized user cannot update an article they do not own.

Execution:
- Arrange: Authenticate a user different from the article's author. Set up the article store to return an article not authored by the current user.
- Act: Call `UpdateArticle` with the request.
- Assert: Validate that a `Forbidden` error status is returned.

Validation:
- The assertion ensures the application enforces ownership of content, consistent with user permissions requirements.

### Scenario 4: Invalid Article Slug

Details:
- Description: Tests the behavior when the slug in `UpdateArticleRequest` cannot be converted to an integer, checking error handling for invalid identifiers.

Execution:
- Arrange: Prepare a request with a non-numeric slug.
- Act: Execute `UpdateArticle`.
- Assert: Check for an `InvalidArgument` error status.

Validation:
- Assert that the error is due to bad input, ensuring data integrity and proper input validation.

### Scenario 5: Article Not Found

Details:
- Description: Handles cases where the article with the given ID doesn't exist in the database.

Execution:
- Arrange: User is authenticated and authorized, but the article store returns `NotFound` for the ID.
- Act: Call `UpdateArticle`.
- Assert: Confirm an `InvalidArgument` error status is returned.

Validation:
- Ensures robustness in handling missing records, a frequent occurrence in database-driven applications.

### Scenario 6: Article Validation Error on Update

Details:
- Description: Tests the situation where updated article data fails validation due to business rules.

Execution:
- Arrange: Setup article data to fail validation criteria during update.
- Act: Invoke `UpdateArticle`.
- Assert: Validate that a `InvalidArgument` error is returned due to validation failures.

Validation:
- Verifies adherence to business rules, preventing invalid data from being stored.

### Scenario 7: Failure in Updating Article Store

Details:
- Description: Ensures proper response when there is an internal error while updating the article in the store.

Execution:
- Arrange: Context includes an authenticated user with authorization, mock article store to return an error on update.
- Act: Call `UpdateArticle`.
- Assert: Check for `Internal` error status indicating update failure.

Validation:
- Asserts application resilience in face of database errors, aligning with reliability requirements.

These scenarios cover essential aspects of the `UpdateArticle` function, ensuring that all critical paths and error possibilities are accounted for and tested.
*/

// ********RoostGPT********
package handler

import (
	"context"
	"errors"
	"fmt"
	"os"
	"testing"

	"github.com/golang/mock/gomock"
	"github.com/google/go-cmp/cmp"
	"github.com/raahii/golang-grpc-realworld-example/auth"
	"github.com/raahii/golang-grpc-realworld-example/model"
	pb "github.com/raahii/golang-grpc-realworld-example/proto"
	"github.com/raahii/golang-grpc-realworld-example/store"
	"github.com/rs/zerolog"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
	"gorm.io/gorm"
)

func TestHandlerUpdateArticle(t *testing.T) {
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()

	// Create mock instances
	logger := zerolog.New(zerolog.ConsoleWriter{Out: os.Stdout})
	userStore := store.NewMockUserStore(ctrl)
	articleStore := store.NewMockArticleStore(ctrl)
	authMock := auth.NewMockAuth(ctrl)

	// Create a new Handler instance
	h := &Handler{
		logger: &logger,
		us:     userStore,
		as:     articleStore,
	}

	type testCase struct {
		name           string
		req            *pb.UpdateArticleRequest
		mockSetup      func()
		expectedError  error
		expectedResult *pb.ArticleResponse
	}

	// Define the test scenarios based on the provided instructions
	testCases := []testCase{
		{
			name: "Successful Article Update",
			req: &pb.UpdateArticleRequest{
				Article: &pb.UpdateArticleRequest_Article{
					Slug:        "1",
					Title:       "Updated Title",
					Description: "Updated Description",
					Body:        "Updated Body",
				},
			},
			mockSetup: func() {
				authMock.EXPECT().GetUserID(gomock.Any()).Return(uint(1), nil)
				userStore.EXPECT().GetByID(uint(1)).Return(&model.User{ID: 1}, nil)
				articleStore.EXPECT().GetByID(uint(1)).Return(&model.Article{ID: 1, Author: model.User{ID: 1}}, nil)
				articleStore.EXPECT().Update(gomock.Any()).Return(nil)
				userStore.EXPECT().IsFollowing(gomock.Any(), gomock.Any()).Return(false, nil)
			},
			expectedError: nil,
			expectedResult: &pb.ArticleResponse{
				Article: &pb.Article{
					Title:       "Updated Title",
					Description: "Updated Description",
					Body:        "Updated Body",
				},
			},
		},
		{
			name: "Unauthenticated User Attempt",
			req: &pb.UpdateArticleRequest{
				Article: &pb.UpdateArticleRequest_Article{
					Slug: "1",
				},
			},
			mockSetup: func() {
				authMock.EXPECT().GetUserID(gomock.Any()).Return(uint(0), errors.New("missing auth token"))
			},
			expectedError: status.Error(codes.Unauthenticated, "unauthenticated"),
		},
		{
			name: "Unauthorized User Update Attempt",
			req: &pb.UpdateArticleRequest{
				Article: &pb.UpdateArticleRequest_Article{
					Slug: "1",
				},
			},
			mockSetup: func() {
				authMock.EXPECT().GetUserID(gomock.Any()).Return(uint(2), nil) // Different user ID
				userStore.EXPECT().GetByID(uint(2)).Return(&model.User{ID: 2}, nil)
				articleStore.EXPECT().GetByID(uint(1)).Return(&model.Article{ID: 1, Author: model.User{ID: 1}}, nil)
			},
			expectedError: status.Error(codes.Unauthenticated, "forbidden"),
		},
		{
			name: "Invalid Article Slug",
			req: &pb.UpdateArticleRequest{
				Article: &pb.UpdateArticleRequest_Article{
					Slug: "not-a-number",
				},
			},
			mockSetup: func() {
				authMock.EXPECT().GetUserID(gomock.Any()).Return(uint(1), nil)
			},
			expectedError: status.Error(codes.InvalidArgument, "invalid article id"),
		},
		{
			name: "Article Not Found",
			req: &pb.UpdateArticleRequest{
				Article: &pb.UpdateArticleRequest_Article{
					Slug: "999",
				},
			},
			mockSetup: func() {
				authMock.EXPECT().GetUserID(gomock.Any()).Return(uint(1), nil)
				userStore.EXPECT().GetByID(uint(1)).Return(&model.User{ID: 1}, nil)
				articleStore.EXPECT().GetByID(uint(999)).Return(nil, gorm.ErrRecordNotFound)
			},
			expectedError: status.Error(codes.InvalidArgument, "invalid article id"),
		},
		{
			name: "Article Validation Error on Update",
			req: &pb.UpdateArticleRequest{
				Article: &pb.UpdateArticleRequest_Article{
					Slug:  "1",
					Title: "",
				},
			},
			mockSetup: func() {
				authMock.EXPECT().GetUserID(gomock.Any()).Return(uint(1), nil)
				userStore.EXPECT().GetByID(uint(1)).Return(&model.User{ID: 1}, nil)
				articleStore.EXPECT().GetByID(uint(1)).Return(&model.Article{ID: 1, Author: model.User{ID: 1}}, nil)
			},
			expectedError: status.Error(codes.InvalidArgument, "validation error"),
		},
		{
			name: "Failure in Updating Article Store",
			req: &pb.UpdateArticleRequest{
				Article: &pb.UpdateArticleRequest_Article{
					Slug:  "1",
					Title: "Valid Title",
				},
			},
			mockSetup: func() {
				authMock.EXPECT().GetUserID(gomock.Any()).Return(uint(1), nil)
				userStore.EXPECT().GetByID(uint(1)).Return(&model.User{ID: 1}, nil)
				articleStore.EXPECT().GetByID(uint(1)).Return(&model.Article{ID: 1, Author: model.User{ID: 1}}, nil)
				articleStore.EXPECT().Update(gomock.Any()).Return(fmt.Errorf("db error"))
			},
			expectedError: status.Error(codes.InvalidArgument, "internal server error"),
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			tc.mockSetup()

			resp, err := h.UpdateArticle(context.Background(), tc.req)

			if tc.expectedError != nil && err.Error() != tc.expectedError.Error() {
				t.Errorf("expected error: %v, got: %v", tc.expectedError, err)
			}

			if tc.expectedResult != nil && !cmp.Equal(resp, tc.expectedResult) {
				t.Errorf("expected response: %v, got: %v", tc.expectedResult, resp)
			}
		})
	}
}
