// ********RoostGPT********
/*
Test generated by RoostGPT for test unit-golang using AI Type Azure Open AI and AI Model india-gpt-4o

ROOST_METHOD_HASH=UnfavoriteArticle_47bfda8100
ROOST_METHOD_SIG_HASH=UnfavoriteArticle_9043d547fd

FUNCTION_DEF=func (h *Handler) UnfavoriteArticle(ctx context.Context, req *pb.UnfavoriteArticleRequest) (*pb.ArticleResponse, error) 
Here are various test scenarios designed for the function `UnfavoriteArticle`:

### Scenario 1: Successful Unfavorite Operation

**Details:**
  - **Description:** Verifies that an existing article is successfully unfavorited by an authenticated user with a valid slug.
  
**Execution:**
  - **Arrange:** 
    - Set up a mock user with a valid user ID in the context.
    - Create a mock article in the article store with a valid slug convertible to an integer.
    - Configure mock responses to ensure that the current user and the article can be retrieved from the user and article stores, respectively.
  - **Act:** 
    - Call `UnfavoriteArticle` with a context containing the mock user and a valid unfavorite article request.
  - **Assert:** 
    - Ensure the function returns an `ArticleResponse` containing the unfavorited article with `Favorited` set to `false`.
  
**Validation:**
  - **Explain:** This verifies that the function correctly updates the article state when all conditions (valid auth, article exists) are met.
  - **Discuss:** This is critical for ensuring users can manage their favorite articles according to desired business logic.

### Scenario 2: Unauthenticated User

**Details:**
  - **Description:** Ensure that the function denies the unfavorite action if a user is not authenticated.
  
**Execution:**
  - **Arrange:** 
    - Provide a context without a user ID.
    - Set up logging to capture error messages.
  - **Act:** 
    - Invoke `UnfavoriteArticle` with an appropriate request.
  - **Assert:** 
    - Check that the function returns an unauthenticated error.
    - Verify that the context captures the correct error message.
  
**Validation:**
  - **Explain:** This ensures the function enforces authentication before allowing modifications to article favorites.
  - **Discuss:** Vital for maintaining security and enforcing access controls according to user sessions.

### Scenario 3: Invalid Slug Conversion

**Details:**
  - **Description:** Check that an error is returned for a request with a slug that cannot be converted to an integer.
  
**Execution:**
  - **Arrange:** 
    - Create a request with a slug containing non-numeric characters.
    - Set up logging for errors.
  - **Act:** 
    - Call `UnfavoriteArticle` with this request.
  - **Assert:** 
    - Confirm that the function returns an invalid argument error.
    - Validate the corresponding log message.
  
**Validation:**
  - **Explain:** Asserts that the function properly handles malformed slugs, preventing further processing.
  - **Discuss:** Essential for input validation to prevent system errors or incorrect data manipulation.

### Scenario 4: Article Not Found

**Details:**
  - **Description:** Validate behavior when attempting to unfavorite an article that does not exist.
  
**Execution:**
  - **Arrange:** 
    - Use a valid slug that corresponds to a nonexistent article in the article store.
    - Mock the article store to return an error for this slug.
  - **Act:** 
    - Execute `UnfavoriteArticle` with this setup.
  - **Assert:** 
    - Ensure the function returns an invalid argument error due to the article not being found.
  
**Validation:**
  - **Explain:** Confirms that the function checks for article existence and returns a proper error code.
  - **Discuss:** It’s important for informing users when they attempt operations on non-existent resources.

### Scenario 5: Failed to Remove Favorite

**Details:**
  - **Description:** Test the function's response when deleting a favorite fails.
  
**Execution:**
  - **Arrange:** 
    - Configure mocks such that the deletion operation returns an error.
    - Set up logging to capture detailed error messages.
  - **Act:** 
    - Call `UnfavoriteArticle` assuming all previous operations succeed but the delete favorite operation fails.
  - **Assert:** 
    - Verify the function responds with an appropriate error and that the error is logged.
  
**Validation:**
  - **Explain:** Ensures robustness by handling errors in backend operations gracefully.
  - **Discuss:** Maintaining consistent state and user feedback is crucial for a seamless user experience.

### Scenario 6: User Not Found from User Store

**Details:**
  - **Description:** Ensure the function handles cases where the user ID from the context does not match any user in the store.
  
**Execution:**
  - **Arrange:** 
    - Use a valid user ID but configure the user store to simulate a user not found condition.
  - **Act:** 
    - Call `UnfavoriteArticle` with this setup.
  - **Assert:** 
    - Check that a not found error is returned and that an appropriate error message is logged.
  
**Validation:**
  - **Explain:** Validates the function’s robustness in session validation and data consistency checks.
  - **Discuss:** Necessary for ensuring that operations are attributed to existing and legitimate users.

These test scenarios cover normal operation, error handling, and edge cases for the `UnfavoriteArticle` function, ensuring comprehensive testing.
*/

// ********RoostGPT********
package handler_test

import (
	"context"
	"errors"
	"testing"

	sqlmock "github.com/DATA-DOG/go-sqlmock"
	"github.com/raahii/golang-grpc-realworld-example/proto"
	"github.com/raahii/golang-grpc-realworld-example/store"
	"github.com/stretchr/testify/assert"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
	"github.com/rs/zerolog"
)

// TestHandlerUnfavoriteArticle tests UnfavoriteArticle function
func TestHandlerUnfavoriteArticle(t *testing.T) {
	// Mocking dependencies
	db, mock, _ := sqlmock.New()
	defer db.Close()

	articleStore := &store.ArticleStore{db: db}
	userStore := &store.UserStore{db: db}
	logger := zerolog.New(nil).With().Logger()

	handler := Handler{
		logger: &logger,
		us:     userStore,
		as:     articleStore,
	}

	tests := []struct {
		name        string
		ctx         context.Context
		req         *proto.UnfavoriteArticleRequest
		setupMock   func()
		expectError error
	}{
		{
			name: "Successful Unfavorite Operation",
			ctx: context.WithValue(context.Background(), "userID", uint(1)),
			req: &proto.UnfavoriteArticleRequest{Slug: "123"},
			setupMock: func() {
				mock.ExpectBegin()
				mock.ExpectExec("UPDATE favorites SET").
					WillReturnResult(sqlmock.NewResult(1, 1))
				mock.ExpectCommit()

				mock.ExpectQuery("SELECT \\* FROM articles WHERE").
					WillReturnRows(sqlmock.NewRows([]string{"id"}).
						AddRow(123))

				mock.ExpectQuery("SELECT \\* FROM users WHERE").
					WillReturnRows(sqlmock.NewRows([]string{"id"}).
						AddRow(1))
			},
			expectError: nil,
		},
		{
			name:        "Unauthenticated User",
			ctx:         context.Background(),
			req:         &proto.UnfavoriteArticleRequest{Slug: "123"},
			setupMock:   func() {},
			expectError: status.Errorf(codes.Unauthenticated, "unauthenticated"),
		},
		{
			name: "Invalid Slug Conversion",
			ctx: context.WithValue(context.Background(), "userID", uint(1)),
			req: &proto.UnfavoriteArticleRequest{Slug: "invalid"},
			setupMock: func() {
				mock.ExpectQuery("SELECT \\* FROM users WHERE").
					WillReturnRows(sqlmock.NewRows([]string{"id"}).
						AddRow(1))
			},
			expectError: status.Error(codes.InvalidArgument, "invalid article id"),
		},
		{
			name: "Article Not Found",
			ctx: context.WithValue(context.Background(), "userID", uint(1)),
			req: &proto.UnfavoriteArticleRequest{Slug: "124"},
			setupMock: func() {
				mock.ExpectQuery("SELECT \\* FROM articles WHERE").
					WillReturnError(errors.New("not found"))

				mock.ExpectQuery("SELECT \\* FROM users WHERE").
					WillReturnRows(sqlmock.NewRows([]string{"id"}).
						AddRow(1))
			},
			expectError: status.Error(codes.InvalidArgument, "invalid article id"),
		},
		{
			name: "Failed to Remove Favorite",
			ctx: context.WithValue(context.Background(), "userID", uint(1)),
			req: &proto.UnfavoriteArticleRequest{Slug: "123"},
			setupMock: func() {
				mock.ExpectBegin()
				mock.ExpectExec("DELETE FROM favorites WHERE").
					WillReturnError(errors.New("failed to delete"))

				mock.ExpectQuery("SELECT \\* FROM articles WHERE").
					WillReturnRows(sqlmock.NewRows([]string{"id"}).
						AddRow(123))

				mock.ExpectQuery("SELECT \\* FROM users WHERE").
					WillReturnRows(sqlmock.NewRows([]string{"id"}).
						AddRow(1))
			},
			expectError: status.Error(codes.InvalidArgument, "failed to remove favorite"),
		},
		{
			name: "User Not Found from User Store",
			ctx: context.WithValue(context.Background(), "userID", uint(1)),
			req: &proto.UnfavoriteArticleRequest{Slug: "123"},
			setupMock: func() {
				mock.ExpectQuery("SELECT \\* FROM users WHERE").
					WillReturnError(errors.New("not found"))
			},
			expectError: status.Error(codes.NotFound, "not user found"),
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.setupMock()
			resp, err := handler.UnfavoriteArticle(tt.ctx, tt.req)

			if tt.expectError != nil {
				assert.Error(t, err)
				assert.Equal(t, tt.expectError.Error(), err.Error())
			} else {
				assert.NoError(t, err)
				assert.NotNil(t, resp)
				assert.Equal(t, false, resp.Article.Favorited)
			}
		})
	}
}
