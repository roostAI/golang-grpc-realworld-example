// ********RoostGPT********
/*
Test generated by RoostGPT for test unit-golang using AI Type Azure Open AI and AI Model india-gpt-4o

ROOST_METHOD_HASH=GetComments_265127fb6a
ROOST_METHOD_SIG_HASH=GetComments_20efd5abae

FUNCTION_DEF=func (h *Handler) GetComments(ctx context.Context, req *pb.GetCommentsRequest) (*pb.CommentsResponse, error) 
```bash
Scenario 1: Valid Article ID, Comments Retrieved Successfully

Details:
  Description: This test checks the normal operation of the `GetComments` function when a valid article ID is passed, ensuring the comments are retrieved successfully.
Execution:
  Arrange: Mock a valid article and associate a list of comments with it. Set up the UserStore to simulate the current user.
  Act: Call the `GetComments` function with a valid slug that corresponds to the mocked article's ID.
  Assert: Verify that the returned `CommentsResponse` contains the expected list of comments, and no error is returned.
Validation:
  Explain the choice of assertion and the logic behind the expected result: The test ensures that comments for a valid article slug are fetched correctly, which is a primary functionality of the application.
  Discuss the importance of the test: Verifies that the function can successfully retrieve comments, fulfilling a core requirement.

Scenario 2: Invalid Article ID, Slug Cannot Be Converted

Details:
  Description: This test verifies error handling when the slug can't be converted to an integer due to invalid input.
Execution:
  Arrange: Configure a `GetCommentsRequest` with a non-numeric slug value.
  Act: Invoke the `GetComments` function using the malformed slug.
  Assert: Check if the function returns an `InvalidArgument` error.
Validation:
  Explain the choice of assertion and the logic behind the expected result: The assertion ensures that the function correctly flags invalid input, maintaining data integrity.
  Discuss the importance of the test: Validates that the input conversion checks are functioning, preventing incorrect data from processing.

Scenario 3: Article Not Found for Provided ID

Details:
  Description: This test validates the function's response to a non-existent article ID.
Execution:
  Arrange: Simulate an environment where the article store does not have an article with the provided ID.
  Act: Call `GetComments` with an ID that doesn't match any article in the store.
  Assert: Confirm that an `InvalidArgument` error is returned.
Validation:
  Explain the choice of assertion and the logic behind the expected result: The test checks for proper error reporting when an article is not available.
  Discuss the importance of the test: Ensures user-friendly error messages and stability by enforcing existence checks.

Scenario 4: Comments Retrieval Failure from ArticleStore

Details:
  Description: This test examines how the function deals with failures in retrieving comments from the store.
Execution:
  Arrange: Configure the article store to fail when attempting to get comments.
  Act: Execute `GetComments` for an article where the retrieval should fail.
  Assert: Check for an `Aborted` error to be returned indicating a retrieval failure.
Validation:
  Explain the choice of assertion and the logic behind the expected result: This verifies that the function gracefully handles lower-layer failures, maintaining system robustness.
  Discuss the importance of the test: Assures that errors are surfaced without crashing the application, vital for resilience.

Scenario 5: User Retrieval and Following Check Failure

Details:
  Description: This test assesses the function's behavior when it cannot retrieve the current user or fails the following status check.
Execution:
  Arrange: Mock a valid article and comments, but cause the UserStore to fail when fetching the current user or checking follow status.
  Act: Call `GetComments` with a valid context and slug.
  Assert: Ensure that the function returns a `NotFound` error during user retrieval or server error for follow status check.
Validation:
  Explain the choice of assertion and the logic behind the expected result: Ensures failure scenarios in user interaction are properly reported.
  Discuss the importance of the test: Confirms reliable handling of user-related data, critical for accuracy in social features.

Scenario 6: Valid User, Comments, and Follow Status Handling

Details:
  Description: This test validates the complete workflow with a valid user, checking if comments are returned with correct author follow status.
Execution:
  Arrange: Set up UserStore and ArticleStore with valid data for articles, comments, and current user.
  Act: Call `GetComments` with a context including the user and a valid article ID.
  Assert: Verify that comments are returned with the expected follow status in author profiles.
Validation:
  Explain the choice of assertion and the logic behind the expected result: Confirms the function correctly integrates user and comment data, crucial for dynamic content rendering.
  Discuss the importance of the test: Ensures comments and author information reflect the current user's relationships, aligning with user experience requirements.
```
These scenarios will help verify that the `GetComments` function behaves as expected across various situations, covering both standard use cases and potential error conditions.
*/

// ********RoostGPT********
package handler_test

import (
	"context"
	"errors"
	"testing"

	sqlmock "github.com/DATA-DOG/go-sqlmock"
	"github.com/raahii/golang-grpc-realworld-example/auth"
	"github.com/raahii/golang-grpc-realworld-example/model"
	pb "github.com/raahii/golang-grpc-realworld-example/proto"
	"github.com/raahii/golang-grpc-realworld-example/store"
	"github.com/rs/zerolog"
	"github.com/stretchr/testify/assert"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
)

func TestHandlerGetComments(t *testing.T) {
	var tests = []struct {
		name                string
		slug                string
		mockArticle         *model.Article
		mockComments        []model.Comment
		mockUser            *model.User
		expectedCommentsLen int
		expectedErrorCode   codes.Code
		setupMocks          func(as *store.ArticleStore, us *store.UserStore, mock sqlmock.Sqlmock)
	}{
		{
			name: "Valid Article ID, Comments Retrieved Successfully",
			slug: "1",
			mockArticle: &model.Article{
				ID: 1,
			},
			mockComments: []model.Comment{
				{
					Body: "Comment 1",
				},
				{
					Body: "Comment 2",
				},
			},
			mockUser: &model.User{},
			expectedCommentsLen: 2,
			expectedErrorCode:   codes.OK,
			setupMocks: func(as *store.ArticleStore, us *store.UserStore, mock sqlmock.Sqlmock) {
				mock.ExpectQuery("SELECT \\* FROM articles").
					WillReturnRows(sqlmock.NewRows([]string{"id"}).AddRow(1))

				mock.ExpectQuery("SELECT \\* FROM comments").
					WillReturnRows(sqlmock.NewRows([]string{"body"}).AddRow("Comment 1").AddRow("Comment 2"))

				mock.ExpectQuery("SELECT \\* FROM users").
					WillReturnRows(sqlmock.NewRows([]string{"id"}).AddRow(1))
			},
		},
		{
			name: "Invalid Article ID, Slug Cannot Be Converted",
			slug: "invalid_slug",
			mockArticle: nil,
			mockComments: nil,
			mockUser: nil,
			expectedCommentsLen: 0,
			expectedErrorCode: codes.InvalidArgument,
			setupMocks: func(as *store.ArticleStore, us *store.UserStore, mock sqlmock.Sqlmock) {
				// No need to set expectations as the GetComments should fail at slug conversion
			},
		},
		{
			name: "Article Not Found for Provided ID",
			slug: "99",
			mockArticle: nil,
			mockComments: nil,
			mockUser: nil,
			expectedCommentsLen: 0,
			expectedErrorCode: codes.InvalidArgument,
			setupMocks: func(as *store.ArticleStore, us *store.UserStore, mock sqlmock.Sqlmock) {
				mock.ExpectQuery("SELECT \\* FROM articles").
					WillReturnError(errors.New("record not found"))
			},
		},
		{
			name: "Comments Retrieval Failure from ArticleStore",
			slug: "1",
			mockArticle: &model.Article{ID: 1},
			mockComments: nil,
			mockUser: nil,
			expectedCommentsLen: 0,
			expectedErrorCode: codes.Aborted,
			setupMocks: func(as *store.ArticleStore, us *store.UserStore, mock sqlmock.Sqlmock) {
				mock.ExpectQuery("SELECT \\* FROM articles").
					WillReturnRows(sqlmock.NewRows([]string{"id"}).AddRow(1))

				mock.ExpectQuery("SELECT \\* FROM comments").
					WillReturnError(errors.New("failed to get comments"))
			},
		},
		{
			name: "User Retrieval and Following Check Failure",
			slug: "1",
			mockArticle: &model.Article{ID: 1},
			mockComments: []model.Comment{
				{
					Body: "Comment 1",
				},
			},
			mockUser: nil,
			expectedCommentsLen: 0,
			expectedErrorCode: codes.NotFound,
			setupMocks: func(as *store.ArticleStore, us *store.UserStore, mock sqlmock.Sqlmock) {
				mock.ExpectQuery("SELECT \\* FROM articles").
					WillReturnRows(sqlmock.NewRows([]string{"id"}).AddRow(1))

				mock.ExpectQuery("SELECT \\* FROM comments").
					WillReturnRows(sqlmock.NewRows([]string{"body"}).AddRow("Comment 1"))

				mock.ExpectQuery("SELECT \\* FROM users").
					WillReturnError(errors.New("user not found"))
			},
		},
		{
			name: "Valid User, Comments, and Follow Status Handling",
			slug: "1",
			mockArticle: &model.Article{ID: 1},
			mockComments: []model.Comment{
				{
					Body: "Comment 1",
				},
			},
			mockUser: &model.User{
				ID: 1,
			},
			expectedCommentsLen: 1,
			expectedErrorCode: codes.OK,
			setupMocks: func(as *store.ArticleStore, us *store.UserStore, mock sqlmock.Sqlmock) {
				mock.ExpectQuery("SELECT \\* FROM articles").
					WillReturnRows(sqlmock.NewRows([]string{"id"}).AddRow(1))
				
				mock.ExpectQuery("SELECT \\* FROM comments").
					WillReturnRows(sqlmock.NewRows([]string{"body"}).AddRow("Comment 1"))
				
				mock.ExpectQuery("SELECT \\* FROM users").
					WillReturnRows(sqlmock.NewRows([]string{"id"}).AddRow(1))
				
				mock.ExpectQuery("SELECT COUNT").
					WillReturnRows(sqlmock.NewRows([]string{"count"}).AddRow(1))
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			db, mock, err := sqlmock.New()
			assert.NoError(t, err)
			defer db.Close()

			as := &store.ArticleStore{DB: db}
			us := &store.UserStore{DB: db}
			logger := zerolog.New(nil)

			tt.setupMocks(as, us, mock)

			h := &Handler{
				logger: &logger,
				us:     us,
				as:     as,
			}

			ctx := context.Background()
			ctx = context.WithValue(ctx, auth.ContextUserKey, tt.mockUser)

			req := &pb.GetCommentsRequest{
				Slug: tt.slug,
			}

			res, err := h.GetComments(ctx, req)
			if tt.expectedErrorCode != codes.OK {
				st, _ := status.FromError(err)
				assert.Equal(t, tt.expectedErrorCode, st.Code(), "Expected error code doesn't match")
			} else {
				assert.NotNil(t, res, "Expected response to be not nil")
				assert.Len(t, res.Comments, tt.expectedCommentsLen, "Expected number of comments doesn't match")
			}

			assert.NoError(t, mock.ExpectationsWereMet())
		})
	}
}
