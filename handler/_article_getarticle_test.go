// ********RoostGPT********
/*
Test generated by RoostGPT for test unit-golang using AI Type Azure Open AI and AI Model india-gpt-4o

ROOST_METHOD_HASH=GetArticle_8db60d3055
ROOST_METHOD_SIG_HASH=GetArticle_ea0095c9f8

FUNCTION_DEF=func (h *Handler) GetArticle(ctx context.Context, req *pb.GetArticleRequest) (*pb.ArticleResponse, error) 
Here are some test scenarios for the `GetArticle` method:

### Scenario 1: Retrieve Article Successfully Without User Authentication

Details:
- Description: Verify that an article can be retrieved successfully when the user is not authenticated, i.e., the user context does not provide a valid user ID.
- Execution:
  - Arrange: Mock the `ArticleStore` to return a specific article for a given slug and set up the context without a user ID.
  - Act: Call `GetArticle` with a valid article slug.
  - Assert: Verify that the article response contains the expected article data with the favorited and author following status set to false.
- Validation:
  - The assertion checks if the correct article details are returned. This is important for users reading articles without an account or being logged in.

### Scenario 2: Retrieve Article Successfully With User Authentication

Details:
- Description: Ensure functionality when a user is authenticated and retrieves an article. Check favorited and following statuses.
- Execution:
  - Arrange: Mock both `ArticleStore` and `UserStore` to return expected data for the article and the user. Set the context with a valid user ID.
  - Act: Invoke `GetArticle` with a valid slug and user context.
  - Assert: Confirm that the response contains the correct favorited and following statuses for the authenticated user.
- Validation:
  - The test verifies user-specific data like favorites and following, ensuring personalized responses, which is crucial for user engagement.

### Scenario 3: Handle Slug Conversion Error

Details:
- Description: Test the function's error handling when the article slug cannot be converted to an integer.
- Execution:
  - Arrange: Prepare a context and request with a non-numeric slug.
  - Act: Call `GetArticle` with the invalid slug.
  - Assert: Expect an error with `codes.InvalidArgument` and an appropriate message.
- Validation:
  - This test ensures robust input validation and error messaging, enhancing the API's reliability and user feedback.

### Scenario 4: Article Not Found Error

Details:
- Description: Test the scenario when the requested article does not exist in the store.
- Execution:
  - Arrange: Mock the `ArticleStore` to return an error when searching for a non-existent article ID.
  - Act: Request an article with a valid but non-existent article slug.
  - Assert: Verify that the error returned has code `codes.InvalidArgument`.
- Validation:
  - Ensures accurate error reporting, essential for debugging and user experience, when a resource is unavailable.

### Scenario 5: User Not Found Despite Valid Token

Details:
- Description: Handle cases where a valid token results in no user found in the store, possibly due to data desynchronization.
- Execution:
  - Arrange: Mock `auth.GetUserID` to return a user ID and `UserStore` to return an error for this user ID.
  - Act: Attempt to retrieve an article with this setup.
  - Assert: Check for a `codes.NotFound` error and the correct error message.
- Validation:
  - This test checks for consistency between authentication and user data, ensuring integrity and reliability of user-dependent functionality.

### Scenario 6: Error in Retrieving Favorited Status

Details:
- Description: Assess how the function handles an error when determining if the article is favorited by the user.
- Execution:
  - Arrange: Set up mocks to return a valid article and user but force an error in `IsFavorited`.
  - Act: Call `GetArticle` under these conditions.
  - Assert: Verify that an `codes.Aborted` error with an internal server error message is returned.
- Validation:
  - Validates error handling for secondary operations, reinforcing system resilience in the face of unexpected failures.

### Scenario 7: Error in Checking Following Status

Details:
- Description: Test error handling during the verification of the following status for an article author.
- Execution:
  - Arrange: Provide mocks for article and user objects and simulate an error in `IsFollowing`.
  - Act: Invoke `GetArticle` with these parameters.
  - Assert: Expect an error with `codes.NotFound` indicating internal server issues.
- Validation:
  - Ensures graceful error handling when retrieving auxiliary user actions, maintaining application stability even if secondary logic fails.

These scenarios should comprehensively cover the `GetArticle` function's possible execution paths and error conditions, ensuring robust testing and validation of its behavior.
*/

// ********RoostGPT********
package handler

import (
	"context"
	"errors"
	"strconv"
	"testing"

	sqlmock "github.com/DATA-DOG/go-sqlmock"
	"github.com/raahii/golang-grpc-realworld-example/proto"
	"github.com/raahii/golang-grpc-realworld-example/store"
	"github.com/rs/zerolog"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
	"gorm.io/driver/sqlite"
	"gorm.io/gorm"
)

// TestHandlerGetArticle tests the GetArticle method of the Handler.
func TestHandlerGetArticle(t *testing.T) {
	db, mock, err := sqlmock.NewWithDSN("sqlmock_db_0")
	if err != nil {
		t.Fatalf("failed to open sqlmock database: %s", err)
	}
	defer db.Close()

	gormDB, err := gorm.Open(sqlite.Open("sqlmock_db_0"), &gorm.Config{})
	if err != nil {
		t.Fatalf("failed to open gorm database: %s", err)
	}

	logger := zerolog.New(nil)
	us := &store.UserStore{Db: gormDB}
	as := &store.ArticleStore{Db: gormDB}
	handler := &Handler{logger: &logger, us: us, as: as}

	tests := []struct {
		name    string
		setup   func()
		request *proto.GetArticleRequest
		expect  func(*testing.T, *proto.ArticleResponse, error)
	}{
		{
			name: "Retrieve Article Successfully Without User Authentication",
			setup: func() {
				mock.ExpectQuery(`SELECT \* FROM "articles" WHERE "articles"\."id" = \$1`).
					WithArgs(1).
					WillReturnRows(sqlmock.NewRows([]string{"id", "title", "description", "body"}).
						AddRow(1, "Test Title", "Test Description", "Test Body"))
				mock.ExpectQuery(`SELECT \* FROM "tags" WHERE "tags"\."article_id" = \$1`).
					WithArgs(1).
					WillReturnRows(sqlmock.NewRows([]string{"name"}))
				mock.ExpectQuery(`SELECT \* FROM "users" WHERE "users"\."id" = \$1`).
					WithArgs(1).
					WillReturnRows(sqlmock.NewRows([]string{"username", "bio", "image"}).
						AddRow("Author", "Bio", "Image"))
			},
			request: &proto.GetArticleRequest{Slug: "1"},
			expect: func(t *testing.T, res *proto.ArticleResponse, err error) {
				if err != nil {
					t.Errorf("Expected nil error, got %v", err)
				}
				if res.Article.Slug != "1" {
					t.Errorf("Expected slug %s, got %s", "1", res.Article.Slug)
				}
				if res.Article.Favorited {
					t.Error("Expected favorited to be false, got true")
				}
				if res.Article.Author.Following {
					t.Error("Expected following to be false, got true")
				}
			},
		},
		{
			name: "Retrieve Article Successfully With User Authentication",
			setup: func() {
				mock.ExpectQuery(`SELECT \* FROM "articles" WHERE "articles"\."id" = \$1`).
					WithArgs(1).
					WillReturnRows(sqlmock.NewRows([]string{"id", "title", "description", "body"}).
						AddRow(1, "Test Title", "Test Description", "Test Body"))
				mock.ExpectQuery(`SELECT \* FROM "tags" WHERE "tags"\."article_id" = \$1`).
					WithArgs(1).
					WillReturnRows(sqlmock.NewRows([]string{"name"}))
				mock.ExpectQuery(`SELECT \* FROM "users" WHERE "users"\."id" = \$1`).
					WithArgs(1).
					WillReturnRows(sqlmock.NewRows([]string{"username", "bio", "image"}).
						AddRow("Author", "Bio", "Image"))
				mock.ExpectQuery(`SELECT \* FROM "users" WHERE "users"\."id" = \$1`).
					WithArgs(1).
					WillReturnRows(sqlmock.NewRows([]string{"username", "bio", "image"}).
						AddRow("User", "Bio", "Image"))
				mock.ExpectQuery(`SELECT count\(\*\) FROM "favorite_articles"`).
					WithArgs(1, 1).
					WillReturnRows(sqlmock.NewRows([]string{"count"}).AddRow(1))
				mock.ExpectQuery(`SELECT count\(\*\) FROM "follows"`).
					WithArgs(1, 1).
					WillReturnRows(sqlmock.NewRows([]string{"count"}).AddRow(1))
			},
			request: &proto.GetArticleRequest{Slug: "1"},
			expect: func(t *testing.T, res *proto.ArticleResponse, err error) {
				if err != nil {
					t.Errorf("Expected nil error, got %v", err)
				}
				if res.Article.Slug != "1" {
					t.Errorf("Expected slug %s, got %s", "1", res.Article.Slug)
				}
				if !res.Article.Favorited {
					t.Error("Expected favorited to be true, got false")
				}
				if !res.Article.Author.Following {
					t.Error("Expected following to be true, got false")
				}
			},
		},
		{
			name: "Handle Slug Conversion Error",
			setup: func() {},
			request: &proto.GetArticleRequest{Slug: "not-an-integer"},
			expect: func(t *testing.T, res *proto.ArticleResponse, err error) {
				if err == nil || status.Code(err) != codes.InvalidArgument {
					t.Errorf("Expected invalid argument error, got %v", err)
				}
			},
		},
		{
			name: "Article Not Found Error",
			setup: func() {
				mock.ExpectQuery(`SELECT \* FROM "articles" WHERE "articles"\."id" = \$1`).
					WithArgs(2).
					WillReturnError(gorm.ErrRecordNotFound)
			},
			request: &proto.GetArticleRequest{Slug: "2"},
			expect: func(t *testing.T, res *proto.ArticleResponse, err error) {
				if err == nil || status.Code(err) != codes.InvalidArgument {
					t.Errorf("Expected invalid argument error, got %v", err)
				}
			},
		},
		{
			name: "User Not Found Despite Valid Token",
			setup: func() {
				mock.ExpectQuery(`SELECT \* FROM "articles" WHERE "articles"\."id" = \$1`).
					WithArgs(1).
					WillReturnRows(sqlmock.NewRows([]string{"id", "title", "description", "body"}).
						AddRow(1, "Test Title", "Test Description", "Test Body"))
				mock.ExpectQuery(`SELECT \* FROM "tags" WHERE "tags"\."article_id" = \$1`).
					WithArgs(1).
					WillReturnRows(sqlmock.NewRows([]string{"name"}))
				mock.ExpectQuery(`SELECT \* FROM "users" WHERE "users"\."id" = \$1`).
					WithArgs(1).
					WillReturnRows(sqlmock.NewRows([]string{"username", "bio", "image"}).
						AddRow("Author", "Bio", "Image"))
				mock.ExpectQuery(`SELECT count\(\*\) FROM "follows"`).
					WithArgs(1, 1).
					WillReturnRows(sqlmock.NewRows([]string{"count"}).AddRow(0))
				mock.ExpectQuery(`SELECT count\(\*\) FROM "favorite_articles"`).
					WithArgs(1, 1).
					WillReturnRows(sqlmock.NewRows([]string{"count"}).AddRow(0))
			},
			request: &proto.GetArticleRequest{Slug: "1"},
			expect: func(t *testing.T, res *proto.ArticleResponse, err error) {
				if err == nil || status.Code(err) != codes.NotFound {
					t.Errorf("Expected not found error, got %v", err)
				}
			},
		},
		{
			name: "Error in Retrieving Favorited Status",
			setup: func() {
				mock.ExpectQuery(`SELECT \* FROM "articles" WHERE "articles"\."id" = \$1`).
					WithArgs(1).
					WillReturnRows(sqlmock.NewRows([]string{"id", "title", "description", "body"}).
						AddRow(1, "Test Title", "Test Description", "Test Body"))
				mock.ExpectQuery(`SELECT \* FROM "tags" WHERE "tags"\."article_id" = \$1`).
					WithArgs(1).
					WillReturnRows(sqlmock.NewRows([]string{"name"}))
				mock.ExpectQuery(`SELECT \* FROM "users" WHERE "users"\."id" = \$1`).
					WithArgs(1).
					WillReturnRows(sqlmock.NewRows([]string{"username", "bio", "image"}).
						AddRow("Author", "Bio", "Image"))
				mock.ExpectQuery(`SELECT \* FROM "users" WHERE "users"\."id" = \$1`).
					WithArgs(1).
					WillReturnRows(sqlmock.NewRows([]string{"username", "bio", "image"}).
						AddRow("User", "Bio", "Image"))
				mock.ExpectQuery(`SELECT count\(\*\) FROM "favorite_articles"`).
					WithArgs(1, 1).
					WillReturnError(errors.New("database error"))
			},
			request: &proto.GetArticleRequest{Slug: "1"},
			expect: func(t *testing.T, res *proto.ArticleResponse, err error) {
				if err == nil || status.Code(err) != codes.Aborted {
					t.Errorf("Expected aborted error, got %v", err)
				}
			},
		},
		{
			name: "Error in Checking Following Status",
			setup: func() {
				mock.ExpectQuery(`SELECT \* FROM "articles" WHERE "articles"\."id" = \$1`).
					WithArgs(1).
					WillReturnRows(sqlmock.NewRows([]string{"id", "title", "description", "body"}).
						AddRow(1, "Test Title", "Test Description", "Test Body"))
				mock.ExpectQuery(`SELECT \* FROM "tags" WHERE "tags"\."article_id" = \$1`).
					WithArgs(1).
					WillReturnRows(sqlmock.NewRows([]string{"name"}))
				mock.ExpectQuery(`SELECT count\(\*\) FROM "favorite_articles"`).
					WithArgs(1, 1).
					WillReturnRows(sqlmock.NewRows([]string{"count"}).AddRow(0))
				mock.ExpectQuery(`SELECT count\(\*\) FROM "follows"`).
					WithArgs(1, 1).
					WillReturnError(errors.New("database error"))
			},
			request: &proto.GetArticleRequest{Slug: "1"},
			expect: func(t *testing.T, res *proto.ArticleResponse, err error) {
				if err == nil || status.Code(err) != codes.NotFound {
					t.Errorf("Expected not found error, got %v", err)
				}
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.setup()
			t.Logf("Running scenario: %s", tt.name)
			res, err := handler.GetArticle(context.Background(), tt.request)
			tt.expect(t, res, err)
		})
	}
}
