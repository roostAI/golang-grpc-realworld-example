// ********RoostGPT********
/*
Test generated by RoostGPT for test unit-golang using AI Type Azure Open AI and AI Model india-gpt-4o

ROOST_METHOD_HASH=ShowProfile_3cf6e3a9fd
ROOST_METHOD_SIG_HASH=ShowProfile_4679c3d9a4

FUNCTION_DEF=func (h *Handler) ShowProfile(ctx context.Context, req *pb.ShowProfileRequest) (*pb.ProfileResponse, error) 
Here are the test scenarios for the `ShowProfile` function, based on the given code and context:

### Scenario 1: Successfully Display a User Profile

**Details:**
- **Description:** This test verifies if the `ShowProfile` function can successfully return a user's profile when provided with a valid username and context containing a user ID.
- **Execution:**
  - **Arrange:** Set up a mock context with a valid user ID. Ensure that both `GetByID` and `GetByUsername` calls on the `UserStore` return valid users. The `IsFollowing` method should return a boolean indicating the follow status.
  - **Act:** Invoke the `ShowProfile` function with the prepared context and a valid `ShowProfileRequest`.
  - **Assert:** Confirm that the `ProfileResponse` contains the expected profile data and that no errors are returned.
- **Validation:**
  - **Explain the choice of assertion:** Verify the presence and correctness of the `ProfileResponse` object.
  - **Discuss the importance:** This scenario is crucial for ensuring the primary functionality of displaying profiles works under normal conditions.

### Scenario 2: Unauthenticated User Request

**Details:**
- **Description:** This test checks whether the function correctly handles cases where the user making the request is unauthenticated.
- **Execution:**
  - **Arrange:** Configure the context to simulate an unauthenticated user by causing `auth.GetUserID` to return an error.
  - **Act:** Call `ShowProfile` with the unauthenticated context and a valid `ShowProfileRequest`.
  - **Assert:** Verify that the function returns a `nil` response and an `Unauthenticated` gRPC status error.
- **Validation:**
  - **Explain the choice of assertion:** Validate the presence of an `Unauthenticated` error to ensure security protocols are enforced.
  - **Discuss the importance:** Ensures unauthorized access attempts are correctly handled, maintaining security integrity.

### Scenario 3: Current User Not Found

**Details:**
- **Description:** Tests the function's behavior when the current user ID from the context does not correspond to any stored user.
- **Execution:**
  - **Arrange:** Use a valid context but manipulate `GetByID` to return an error simulating a missing user in the store.
  - **Act:** Execute `ShowProfile` using this context and a valid request.
  - **Assert:** Check for a `nil` response and a `NotFound` error.
- **Validation:**
  - **Explain the choice of assertion:** Expect a `NotFound` status to ensure the application handles user consistency checks.
  - **Discuss the importance:** Verifies system robustness in handling unexpected inconsistencies in user data.

### Scenario 4: Requested User Not Found

**Details:**
- **Description:** Ensures the function correctly responds when the username in the request does not exist in the user store.
- **Execution:**
  - **Arrange:** Enable `GetByUsername` to return an error indicating the requested user could not be found.
  - **Act:** Invoke `ShowProfile` with a valid context and a request containing a non-existing username.
  - **Assert:** Confirm a `nil` response and a `NotFound` error.
- **Validation:**
  - **Explain the choice of assertion:** Expect a `NotFound` error to confirm profile requests for non-existent users are handled well.
  - **Discuss the importance:** Critical for maintaining proper feedback in user experiences and database integrity.

### Scenario 5: Error When Checking Follow Status

**Details:**
- **Description:** Examines the function's response when it encounters an error while determining if the current user follows the requested user.
- **Execution:**
  - **Arrange:** Ensure that `IsFollowing` returns an error, while `GetByID` and `GetByUsername` return valid users.
  - **Act:** Call `ShowProfile` with the necessary context and request.
  - **Assert:** Verify that the response is `nil` and the error returned is an `Internal` server error.
- **Validation:**
  - **Explain the choice of assertion:** Expect an `Internal` error to check if unexpected internal faults are spotted.
  - **Discuss the importance:** Confirms system resilience and that appropriate messages are given during internal faults.

### Scenario 6: Malformed Request

**Details:**
- **Description:** Tests how the function deals with malformed requests, such as when the username is empty or invalid.
- **Execution:**
  - **Arrange:** Create a `ShowProfileRequest` with an empty or malformed username.
  - **Act:** Execute `ShowProfile` with a valid context and the malformed request.
  - **Assert:** Verify if appropriate handling or error responses occur. Depending on implementation, it might reject directly or proceed to `GetByUsername`.
- **Validation:**
  - **Explain the choice of assertion:** Depends on if initial validation rejects the malformed request or if operations continue and fail later.
  - **Discuss the importance:** Ensures robustness against invalid inputs improving user experience and system reliability.

These test scenarios cover a range of typical, boundary, and error conditions to ensure comprehensive testing of the `ShowProfile` function.
*/

// ********RoostGPT********
package handler

import (
	"context"
	"errors"
	"testing"

	"github.com/DATA-DOG/go-sqlmock"
	"github.com/raahii/golang-grpc-realworld-example/auth"
	"github.com/raahii/golang-grpc-realworld-example/model"
	pb "github.com/raahii/golang-grpc-realworld-example/proto"
	"github.com/raahii/golang-grpc-realworld-example/store"
	"github.com/rs/zerolog"
	"github.com/rs/zerolog/log"
	"github.com/stretchr/testify/assert"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
	"gorm.io/driver/mysql"
	"gorm.io/gorm"
)

func TestHandlerShowProfile(t *testing.T) {
	var db *gorm.DB
	var mock sqlmock.Sqlmock
	mockDB, mock, _ := sqlmock.New()
	defer mockDB.Close()
	
	dialector := mysql.New(mysql.Config{
		Conn:                      mockDB,
		SkipInitializeWithVersion: true,
	})
	db, _ = gorm.Open(dialector)

	userStore := &store.UserStore{DB: db}
	logger := log.Logger
	handler := &Handler{
		logger: &logger,
		us:     userStore,
	}

	testCases := []struct {
		name           string
		setupMock      func()
		req            *pb.ShowProfileRequest
		expectedResult *pb.ProfileResponse
		expectedError  codes.Code
	}{
		{
			name: "Successfully Display a User Profile",
			setupMock: func() {
				mock.ExpectQuery("SELECT \\* FROM `users`").
					WillReturnRows(sqlmock.NewRows([]string{"id"}).AddRow(100))
				mock.ExpectQuery("SELECT \\* FROM `users`").
					WillReturnRows(sqlmock.NewRows([]string{"id"}).AddRow(101))
				mock.ExpectQuery("SELECT count\\(\\*\\) FROM `follows`").
					WillReturnRows(sqlmock.NewRows([]string{"count"}).AddRow(1))
			},
			req: &pb.ShowProfileRequest{
				Username: "existentuser",
			},
			expectedResult: &pb.ProfileResponse{Profile: &pb.Profile{Username: "existentuser", Following: true}},
			expectedError:  codes.OK,
		},
		{
			name: "Unauthenticated User Request",
			setupMock: func() {
				auth.GetUserID = func(ctx context.Context) (uint, error) {
					return 0, errors.New("unauthenticated")
				}
			},
			req: &pb.ShowProfileRequest{
				Username: "existentuser",
			},
			expectedResult: nil,
			expectedError:  codes.Unauthenticated,
		},
		{
			name: "Current User Not Found",
			setupMock: func() {
				auth.GetUserID = func(ctx context.Context) (uint, error) {
					return 102, nil
				}
				mock.ExpectQuery("SELECT \\* FROM `users`").
					WillReturnError(errors.New("record not found"))
			},
			req: &pb.ShowProfileRequest{
				Username: "existentuser",
			},
			expectedResult: nil,
			expectedError:  codes.NotFound,
		},
		{
			name: "Requested User Not Found",
			setupMock: func() {
				auth.GetUserID = func(ctx context.Context) (uint, error) {
					return 101, nil
				}
				mock.ExpectQuery("SELECT \\* FROM `users`").
					WillReturnRows(sqlmock.NewRows([]string{"id"}).AddRow(101))
				mock.ExpectQuery("SELECT \\* FROM `users` WHERE `username` = \\?").
					WithArgs("nonexistentuser").WillReturnError(errors.New("record not found"))
			},
			req: &pb.ShowProfileRequest{
				Username: "nonexistentuser",
			},
			expectedResult: nil,
			expectedError:  codes.NotFound,
		},
		{
			name: "Error When Checking Follow Status",
			setupMock: func() {
				auth.GetUserID = func(ctx context.Context) (uint, error) {
					return 101, nil
				}
				mock.ExpectQuery("SELECT \\* FROM `users`").
					WillReturnRows(sqlmock.NewRows([]string{"id"}).AddRow(101))
				mock.ExpectQuery("SELECT \\* FROM `users` WHERE `username` = \\?").
					WithArgs("existentuser").WillReturnRows(sqlmock.NewRows([]string{"id"}).AddRow(102))
				mock.ExpectQuery("SELECT count\\(\\*\\) FROM `follows`").
					WillReturnError(errors.New("error checking follow status"))
			},
			req: &pb.ShowProfileRequest{
				Username: "existentuser",
			},
			expectedResult: nil,
			expectedError:  codes.Internal,
		},
		{
			name: "Malformed Request",
			setupMock: func() {
				auth.GetUserID = func(ctx context.Context) (uint, error) {
					return 101, nil
				}
			},
			req:           &pb.ShowProfileRequest{Username: ""},
			expectedResult: nil,
			expectedError:  codes.InvalidArgument,
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			tc.setupMock()
			ctx := context.Background()

			resp, err := handler.ShowProfile(ctx, tc.req)

			if tc.expectedError == codes.OK {
				assert.Nil(t, err)
				assert.Equal(t, tc.expectedResult, resp)
			} else {
				assert.NotNil(t, err)
				st, _ := status.FromError(err)
				assert.Equal(t, tc.expectedError, st.Code())
			}

			assert.NoError(t, mock.ExpectationsWereMet(), "there were unfulfilled expectations")
		})
	}
}
